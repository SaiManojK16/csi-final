\documentclass[11pt,letterpaper]{article}
\usepackage[utf8]{inputenc}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{enumitem}
\usepackage{tikz}
\usetikzlibrary{shapes,arrows,positioning,decorations.pathreplacing,calc}

\geometry{margin=1in}

\title{Milestone 4: Architectural Software Design}
\author{CSI 680 - Team Information}
\date{November 4, 2024}

\begin{document}

\maketitle

\section*{Team Information}
\textbf{Team Number:} [TO BE FILLED]\\
\textbf{Team Name:} Acceptly\\
\textbf{Team Members:} [TO BE FILLED - List all team members as they appear in class roster]

\section{Project Summary}

\subsection{Overview}
Acceptly is an interactive web-based educational platform designed to help students learn and master Finite Automata (FA) theory through hands-on practice and AI-powered tutoring. The application provides a visual canvas for building finite automata, automated testing capabilities, and intelligent AI assistance that guides students through the learning process without revealing direct solutions.

\subsection{Core Requirements and Goals}
Based on the initial project requirements and current implementation, the system fulfills the following objectives:

\begin{enumerate}
    \item \textbf{Visual FA Builder:} Provide an interactive canvas where students can visually construct finite automata by adding states, transitions, and configuring accepting states.
    
    \item \textbf{Automated Testing:} Implement a comprehensive test suite that validates student-constructed automata against predefined test cases, providing immediate feedback on correctness.
    
    \item \textbf{AI-Powered Tutoring:} Integrate Google Gemini AI to provide contextual hints, error analysis, and concept explanations using a Socratic teaching method that guides without giving direct answers.
    
    \item \textbf{Progress Tracking:} Maintain detailed user progress across multiple FA problems and MCQ quizzes, tracking attempts, scores, and completion status.
    
    \item \textbf{Quiz System:} Offer multiple-choice question (MCQ) quizzes to reinforce theoretical understanding alongside hands-on FA construction.
    
    \item \textbf{Performance Analytics:} Generate comprehensive insights and analytics based on user performance, identifying strengths, weaknesses, and areas for improvement.
    
    \item \textbf{User Authentication:} Secure user accounts with registration, login, and session management.
\end{enumerate}

\subsection{Changes Since Milestone 1}
Since the initial project proposal (Milestone 1), the following changes and enhancements have been implemented:

\begin{itemize}
    \item \textbf{Topic Scope Refinement:} The initial proposal included three topics: Graphs, SQL Queries, and Finite Automata. The implementation focused specifically on Finite Automata, allowing for deeper feature development and more comprehensive functionality within this domain. This decision was made to ensure high-quality implementation rather than spreading resources across multiple topics.
    
    \item \textbf{Technology Stack Evolution:}
    \begin{itemize}
        \item \textbf{Backend:} Changed from Python (as proposed) to Node.js/Express.js for better integration with the React frontend and unified JavaScript ecosystem
        \item \textbf{Database:} Changed from PostgreSQL (as proposed) to MongoDB for flexible schema design and easier integration with Node.js
        \item \textbf{Frontend:} Maintained React.js as planned
    \end{itemize}
    
    \item \textbf{Expanded Problem Set:} The system now includes multiple FA problems with varying difficulty levels (Easy, Medium, Hard) and a comprehensive set of MCQ quizzes covering different automata theory concepts.
    
    \item \textbf{Comprehensive Analytics Dashboard:} Added an Insights page that provides detailed performance analytics, AI-generated recommendations, and concept-specific improvement tips, fulfilling the requirement for intelligent feedback and progress tracking.
    
    \item \textbf{Enhanced User Experience:} Implemented guided tours, improved UI/UX design based on Milestone 2 specifications, and responsive layouts for better accessibility.
    
    \item \textbf{Robust Backend Architecture:} Implemented a full-stack architecture with Express.js backend, MongoDB database, and RESTful API design, providing secure authentication and persistent data storage.
    
    \item \textbf{Advanced Progress Tracking:} Extended progress tracking to include detailed statistics such as best scores, attempt counts, submission timestamps, and concept-level performance analysis, supporting the dynamic difficulty adjustment concept from Milestone 1.
    
    \item \textbf{AI Integration:} Successfully integrated Google Gemini AI (instead of rule-based + lightweight ML as initially proposed) for more sophisticated and context-aware feedback generation, maintaining the intelligent feedback engine requirement.
\end{itemize}

\section{Design Pattern Used}

\subsection{N-Tier Architecture}

The application follows the \textbf{N-Tier Architecture} pattern, which is a fundamental design pattern for web applications. This architecture separates the application into distinct layers, where each layer only communicates with its two adjacent layers, providing security, reliability, and separation of concerns.

\subsubsection{Architecture Layers}

The Acceptly application implements a 4-tier architecture:

\begin{enumerate}
    \item \textbf{Presentation Layer (Client):} React frontend application running in the browser, providing the user interface and handling client-side interactions. This layer includes:
    \begin{itemize}
        \item React components for UI rendering
        \item Client-side routing and navigation (React Router)
        \item Event handling and user interactions
        \item Canvas API for visual FA construction
        \item Local state management via Context API
    \end{itemize}
    
    \item \textbf{Business Logic Layer (Application Server):} Express.js backend server handling business logic, authentication, and request processing. This layer includes:
    \begin{itemize}
        \item Express.js web framework for HTTP request handling
        \item Authentication middleware for JWT token verification
        \item RESTful API route handlers
        \item Business logic for progress tracking and user management
        \item Error handling and response formatting
    \end{itemize}
    
    \item \textbf{Data Layer:} Mongoose ODM providing data access abstraction and schema definition. This layer includes:
    \begin{itemize}
        \item User model schema with validation rules
        \item Data transformation between JavaScript objects and MongoDB documents
        \item Connection management to the database
        \item Query abstraction and data access methods
    \end{itemize}
    
    \item \textbf{Storage Layer:} MongoDB database providing persistent data storage. This layer includes:
    \begin{itemize}
        \item BSON document storage
        \item User account and progress data persistence
        \item Indexing and query optimization
    \end{itemize}
\end{enumerate}

\subsubsection{Layer Communication}

The architecture enforces strict communication rules:
\begin{itemize}
    \item \textbf{Presentation $\leftrightarrow$ Business Logic:} Communication via HTTP/HTTPS using RESTful API calls. The frontend sends JSON requests and receives JSON responses.
    \item \textbf{Business Logic $\leftrightarrow$ Data Layer:} Communication through Mongoose ODM, which provides a JavaScript interface to MongoDB.
    \item \textbf{Data Layer $\leftrightarrow$ Storage:} Direct database operations using MongoDB's native protocols.
    \item \textbf{No Direct Communication:} The Presentation Layer cannot directly access the Storage Layer, and the Business Logic Layer cannot bypass the Data Layer. This separation ensures security and maintainability.
\end{itemize}

\subsubsection{Benefits of N-Tier Architecture}

\begin{itemize}
    \item \textbf{Security:} Sensitive database operations are isolated in the backend, preventing direct client access to data stores.
    \item \textbf{Reliability:} Failures in one layer do not cascade to other layers, allowing for independent error handling and recovery.
    \item \textbf{Separation of Concerns:} Each layer has a distinct responsibility, making the codebase more maintainable and testable.
    \item \textbf{Technology Separation:} Different technologies can be used in each layer (React for frontend, Node.js for backend, MongoDB for storage) without tight coupling.
    \item \textbf{Scalability:} Each layer can be scaled independently based on demand.
\end{itemize}

\subsection{Web Application Control Flow}

The application utilizes several web-specific control flow mechanisms beyond traditional procedural control flow:

\subsubsection{Asynchronous Message Passing (Ajax)}
The frontend communicates with the backend using asynchronous HTTP requests, allowing the UI to remain responsive while waiting for server responses. This is implemented through:
\begin{itemize}
    \item \texttt{fetch()} API calls in \texttt{APIService} for RESTful API communication
    \item Promise-based async/await patterns for handling asynchronous operations
    \item Non-blocking UI updates during data fetching
\end{itemize}

\subsubsection{Client-Side Routing and Redirects}
React Router implements client-side routing and redirects, following web application control flow principles:
\begin{itemize}
    \item \textbf{Redirects:} Unauthenticated users are redirected to \texttt{/auth} when accessing protected routes, and authenticated users are redirected to \texttt{/dashboard} when accessing public routes. Redirects tell the client to resend the request to a different URL, making the client aware of the change.
    \item \textbf{Programmatic Navigation:} Components use \texttt{useNavigate()} hook to programmatically change routes after user actions (e.g., after quiz submission). This represents operational transitions where users change control flow through the browser.
    \item \textbf{URL-based State:} Route parameters (e.g., \texttt{/practice/fa/:problemId}) pass state between components via URL, enabling bookmarkable state and browser history navigation.
    \item \textbf{Browser History:} Users can use back button, forward button, and browser history to navigate through application states, representing operational transitions in web app control flow.
\end{itemize}

\textbf{Note on Forward vs Redirect:} The application uses redirects (client-side via React Router) rather than server-side forwards. Redirects are appropriate here because:
\begin{itemize}
    \item The client needs to be aware of route changes for proper authentication state management
    \item Route changes can target different components within the same React application
    \item Client-side redirects preserve React Router's history and state management
\end{itemize}

\subsubsection{Event Handling}
Client-side event handling enables interactive user interfaces:
\begin{itemize}
    \item User interaction events (clicks, keyboard input, mouse movements) trigger component state updates
    \item Form submissions handled through React event handlers
    \item Canvas interactions for FA construction (click, drag, right-click events)
\end{itemize}

\subsection{Model-View-Controller (MVC) Pattern Influence}

While React doesn't strictly follow MVC, the application exhibits MVC-like separation:

\begin{itemize}
    \item \textbf{Model:} User data models in MongoDB (User schema), business logic in backend route handlers
    \item \textbf{View:} React components rendering the UI (presentation layer)
    \item \textbf{Controller:} React Router for navigation, event handlers in components, and backend route handlers for request processing
\end{itemize}

\subsection{Additional Design Patterns}

The application also incorporates complementary patterns:

\begin{itemize}
    \item \textbf{Context API Pattern:} \texttt{AuthContext} provides global authentication state management, eliminating prop drilling and centralizing authentication logic.
    
    \item \textbf{Service Layer Pattern:} \texttt{APIService} and \texttt{GeminiService} encapsulate external service communication, providing clean abstraction between components and external dependencies.
    
    \item \textbf{Protected Route Pattern:} \texttt{ProtectedRoute} and \texttt{PublicRoute} components act as route guards, implementing access control based on authentication status.
    
    \item \textbf{Component Composition:} Complex UIs built from smaller, reusable components (\texttt{Header}, \texttt{Card}, \texttt{AlertDialog}) promoting code reusability and maintainability.
\end{itemize}

\section{Software Components}

\subsection{High-Level Components (N-Tier Architecture Layers)}

The software components are organized according to the N-tier architecture pattern, with each tier representing a distinct layer of the application:

\subsubsection{1. Presentation Layer - Frontend Application (React)}
\textbf{Purpose:} Provides the user interface and handles all client-side interactions. This is the client-side layer of the N-tier architecture.

\textbf{Component Pieces:}
\begin{itemize}
    \item React Router for navigation and routing control flow
    \item Context API for state management
    \item Component library for UI elements
    \item Canvas API for visual FA construction
    \item Event handling for user interactions
\end{itemize}

\textbf{Layer Communication:} Communicates with Business Logic Layer via HTTP/HTTPS using RESTful API calls.

\subsubsection{2. Business Logic Layer - Backend API Server (Express.js)}
\textbf{Purpose:} Handles business logic, authentication, and request processing. This is the application server layer of the N-tier architecture.

\textbf{Component Pieces:}
\begin{itemize}
    \item Express.js web framework for HTTP request handling
    \item Authentication middleware for JWT token verification
    \item RESTful API routes (message passing endpoints)
    \item Error handling middleware
    \item Business logic for progress tracking and user management
\end{itemize}

\textbf{Layer Communication:} Receives requests from Presentation Layer via HTTP/HTTPS and communicates with Data Layer through Mongoose ODM.

\subsubsection{3. Data Layer - Mongoose ODM}
\textbf{Purpose:} Provides data access abstraction and schema definition. This layer bridges the Business Logic Layer and Storage Layer.

\textbf{Component Pieces:}
\begin{itemize}
    \item Mongoose ODM for schema definition and validation
    \item User model schema
    \item Data transformation between JavaScript objects and MongoDB documents
    \item Connection management to the database
    \item Query abstraction and data access methods
\end{itemize}

\textbf{Layer Communication:} Receives data operations from Business Logic Layer and communicates with Storage Layer using MongoDB native protocols.

\subsubsection{4. Storage Layer - Database (MongoDB)}
\textbf{Purpose:} Stores persistent user data, progress tracking, and application state. This is the database server layer, typically on different hardware (layered architecture).

\textbf{Component Pieces:}
\begin{itemize}
    \item MongoDB database server (document-oriented NoSQL database)
    \item BSON document storage
    \item Indexing and query optimization
    \item Data persistence and durability
\end{itemize}

\textbf{Layer Communication:} Receives data operations from Data Layer through MongoDB protocols.

\subsubsection{5. External Service - AI Service (Google Gemini)}
\textbf{Purpose:} Provides intelligent tutoring, hints, and educational feedback. This is an external service accessed via HTTPS, not part of the core N-tier architecture but integrated through the Presentation Layer.

\textbf{Component Pieces:}
\begin{itemize}
    \item Google Generative AI SDK
    \item Gemini 2.0 Flash model
    \item Prompt engineering system
    \item Response processing
\end{itemize}

\textbf{Communication:} Accessed directly from Presentation Layer via HTTPS (asynchronous message passing).

\subsection{Class-Level Components}

\subsubsection{Frontend Classes/Services}

\paragraph{APIService (apiService.js)}
\textbf{Purpose:} Centralized service for all backend API communication.

\textbf{Methods:}
\begin{itemize}
    \item \texttt{setToken(token)} - Stores authentication token
    \item \texttt{getHeaders()} - Constructs HTTP headers with authentication
    \item \texttt{request(endpoint, options)} - Generic HTTP request method
    \item \texttt{signup(username, email, password)} - User registration
    \item \texttt{login(email, password)} - User authentication
    \item \texttt{getCurrentUser()} - Retrieve current user data
    \item \texttt{getProgress()} - Fetch user progress
    \item \texttt{updateFAProgress(problemId, data)} - Update FA problem progress
    \item \texttt{updateQuizProgress(quizId, data)} - Update quiz progress
\end{itemize}

\paragraph{GeminiService (geminiService.js)}
\textbf{Purpose:} Manages interactions with Google Gemini AI for educational assistance.

\textbf{Methods:}
\begin{itemize}
    \item \texttt{getHint(problemStatement, currentFA)} - Generate contextual hints
    \item \texttt{analyzeErrors(problemStatement, currentFA, testResults)} - Analyze failed tests
    \item \texttt{explainConcept(concept)} - Provide concept explanations
    \item \texttt{getInsights(progress)} - Generate overall performance insights
    \item \texttt{getRecommendations(progress, weakConcepts)} - Generate study recommendations
    \item \texttt{getConceptImprovement(concept, progress)} - Get concept-specific tips
\end{itemize}

\paragraph{AuthContext (AuthContext.js)}
\textbf{Purpose:} Manages global authentication state and provides authentication methods.

\textbf{Methods:}
\begin{itemize}
    \item \texttt{login(email, password)} - Authenticate user
    \item \texttt{signup(username, email, password)} - Register new user
    \item \texttt{logout()} - Clear authentication state
    \item \texttt{resetPassword(email)} - Initiate password reset
    \item \texttt{updateProgress(type, data)} - Update local progress state
\end{itemize}

\paragraph{State Management:}
\begin{itemize}
    \item \texttt{user} - Current user object
    \item \texttt{loading} - Authentication loading state
    \item \texttt{isAuthenticated} - Boolean authentication status
\end{itemize}

\subsubsection{Backend Classes/Models}

\paragraph{User Model (User.js)}
\textbf{Purpose:} Defines the MongoDB schema for user data and progress tracking.

\textbf{Schema Fields:}
\begin{itemize}
    \item \texttt{username} - Unique username
    \item \texttt{email} - Unique email address
    \item \texttt{password} - Hashed password
    \item \texttt{progress} - Nested object containing:
    \begin{itemize}
        \item \texttt{faSimulation} - FA problem progress
        \item \texttt{mcqs} - Quiz progress
    \end{itemize}
    \item \texttt{createdAt} - Account creation timestamp
    \item \texttt{lastLogin} - Last login timestamp
\end{itemize}

\textbf{Methods:}
\begin{itemize}
    \item \texttt{comparePassword(candidatePassword)} - Password verification
    \item \texttt{updateProgress(type, data)} - Update progress statistics
\end{itemize}

\paragraph{Pre-save Hooks:}
\begin{itemize}
    \item Password hashing using bcrypt before saving
\end{itemize}

\subsection{Page-Level Components}

\subsubsection{1. LandingPage}
\textbf{Purpose:} Public landing page with project overview and features.

\subsubsection{2. UnifiedAuthPage}
\textbf{Purpose:} Combined login/signup interface with form validation.

\subsubsection{3. Dashboard}
\textbf{Purpose:} Main user dashboard displaying progress overview and quick access.

\subsubsection{4. ProblemSelection}
\textbf{Purpose:} Browse and filter available FA problems and quizzes.

\subsubsection{5. FASimulation}
\textbf{Purpose:} Interactive FA construction environment with canvas, testing, and AI assistance.

\subsubsection{6. QuizPage}
\textbf{Purpose:} MCQ quiz interface with timer and submission handling.

\subsubsection{7. Insights}
\textbf{Purpose:} Performance analytics, AI insights, and recommendations dashboard.

\subsection{Reusable UI Components}

\subsubsection{1. Header}
\textbf{Purpose:} Application navigation and user menu.

\subsubsection{2. AutomataCanvas}
\textbf{Purpose:} Canvas-based visualization for FA states and transitions.

\subsubsection{3. StringTester}
\textbf{Purpose:} Test case execution and result display.

\subsubsection{4. AIHelper}
\textbf{Purpose:} Floating AI assistant interface for hints and analysis.

\subsubsection{5. QuizResults}
\textbf{Purpose:} Post-quiz results display with analytics.

\subsubsection{6. AlertDialog}
\textbf{Purpose:} Reusable modal dialog component.

\subsubsection{7. Pagination}
\textbf{Purpose:} Pagination controls for problem lists.

\subsubsection{8. GuidedTour}
\textbf{Purpose:} Interactive tutorial system for onboarding.

\subsection{Backend Route Handlers}

\subsubsection{1. Auth Routes (/api/auth)}
\textbf{Purpose:} Handle authentication and user management.

\textbf{Endpoints:}
\begin{itemize}
    \item \texttt{POST /signup} - User registration
    \item \texttt{POST /login} - User authentication
    \item \texttt{GET /me} - Get current user (protected)
    \item \texttt{POST /check-email} - Email availability check
    \item \texttt{POST /reset-password} - Password reset initiation
\end{itemize}

\textbf{Middleware:}
\begin{itemize}
    \item \texttt{authMiddleware} - JWT token verification
    \item \texttt{generateToken} - JWT token generation
\end{itemize}

\subsubsection{2. Progress Routes (/api/progress)}
\textbf{Purpose:} Manage user progress tracking.

\textbf{Endpoints:}
\begin{itemize}
    \item \texttt{GET /} - Get user progress (protected)
    \item \texttt{POST /fa/:problemId} - Update FA problem progress (protected)
    \item \texttt{POST /quiz/:quizId} - Update quiz progress (protected)
\end{itemize}

\subsubsection{3. Problems Routes (/api/problems)}
\textbf{Purpose:} Serve problem and quiz data.

\textbf{Endpoints:}
\begin{itemize}
    \item \texttt{GET /} - Get all problems/quizzes with filters (protected)
    \item \texttt{GET /:id} - Get specific problem/quiz (protected)
\end{itemize}

\section{Wiring Diagram}

The following diagram illustrates the N-tier architecture and how components connect and communicate across layers, following the design pattern described in Section 2:

\begin{figure}[h]
\centering
\includegraphics[width=0.9\textwidth]{wiring_diagram.png}
\caption{N-Tier Architecture Diagram showing component layers and communication. The diagram shows four tiers: Presentation Layer (Tier 1) with React Frontend including React Router, AuthContext, APIService, and GeminiService; Business Logic Layer (Tier 2) with Express.js Framework, Authentication Middleware (JWT), and REST API Routes; Data Layer (Tier 3) with Mongoose ODM and User Model; and Storage Layer (Tier 4) with MongoDB Database. Each layer only communicates with its adjacent layers, following N-tier architecture principles.}
\label{fig:wiring-diagram}
\end{figure}

\subsection{Architecture Overview}

The diagram visualizes the 4-tier architecture pattern described in Section 2.1, showing how components are organized and how they communicate:

\begin{itemize}
    \item \textbf{Tier 1 - Presentation Layer:} Contains the React frontend application with its key services and components:
    \begin{itemize}
        \item \textbf{React Router:} Handles client-side routing and navigation, implementing the control flow mechanisms described in Section 2.2.2
        \item \textbf{AuthContext:} Manages global authentication state using the Context API pattern (Section 2.3)
        \item \textbf{APIService:} Encapsulates HTTP communication with the backend, implementing the Service Layer pattern (Section 2.3)
        \item \textbf{GeminiService:} Handles asynchronous communication with Google Gemini AI via HTTPS
    \end{itemize}
    
    \item \textbf{Tier 2 - Business Logic Layer:} Contains the Express.js backend server components:
    \begin{itemize}
        \item \textbf{Express.js Framework:} Web framework for HTTP request handling
        \item \textbf{Authentication Middleware (JWT):} Verifies JWT tokens for protected routes
        \item \textbf{REST API Routes:} Route handlers for authentication, progress tracking, and problem/quizzes endpoints
    \end{itemize}
    
    \item \textbf{Tier 3 - Data Layer:} Contains Mongoose ODM components:
    \begin{itemize}
        \item \textbf{Mongoose ODM:} Provides data access abstraction and schema definition
        \item \textbf{User Model:} Schema definition with validation rules for user data
    \end{itemize}
    
    \item \textbf{Tier 4 - Storage Layer:} Contains the MongoDB database for persistent data storage
    
    \item \textbf{External Service:} Google Gemini AI, accessed asynchronously from the Presentation Layer via HTTPS (implementing the asynchronous message passing pattern from Section 2.2.1)
\end{itemize}

\subsection{Communication Protocols}

The diagram shows the communication protocols between layers, as described in Section 2.1.2:

\begin{itemize}
    \item \textbf{Presentation $\leftrightarrow$ Business Logic:} Communication via HTTP/HTTPS using RESTful API calls. The \texttt{APIService} sends JSON requests and receives JSON responses. This implements the asynchronous message passing (Ajax) pattern described in Section 2.2.1.
    
    \item \textbf{Business Logic $\leftrightarrow$ Data Layer:} Communication through Mongoose ODM, which provides a JavaScript interface to MongoDB. The REST API Routes and Auth Middleware use Mongoose to interact with the User Model.
    
    \item \textbf{Data Layer $\leftrightarrow$ Storage:} Direct database operations using MongoDB's native protocols. The Mongoose ODM translates JavaScript operations into MongoDB protocol calls.
    
    \item \textbf{Presentation $\leftrightarrow$ External Service:} The \texttt{GeminiService} communicates directly with Google Gemini AI via asynchronous HTTPS requests, following the Ajax pattern for non-blocking external API calls.
    
    \item \textbf{No Direct Communication:} The architecture enforces that the Presentation Layer cannot directly access the Storage Layer, and the Business Logic Layer cannot bypass the Data Layer. This separation ensures security and maintainability as described in Section 2.1.3.
\end{itemize}

\subsection{Data Flow Description}

\subsubsection{Authentication Flow}
\begin{enumerate}
    \item User submits credentials via \texttt{UnifiedAuthPage}
    \item \texttt{AuthContext.login()} calls \texttt{APIService.login()}
    \item \texttt{APIService} sends POST request to \texttt{/api/auth/login}
    \item Backend validates credentials, generates JWT token
    \item Token returned to frontend, stored in localStorage
    \item \texttt{AuthContext} updates user state, triggers re-render
\end{enumerate}

\subsubsection{Progress Update Flow}
\begin{enumerate}
    \item User completes FA problem or quiz in \texttt{FASimulation} or \texttt{QuizPage}
    \item Component calls \texttt{APIService.updateFAProgress()} or \texttt{updateQuizProgress()}
    \item \texttt{APIService} sends POST request with JWT token to \texttt{/api/progress/fa/:problemId} or \texttt{/api/progress/quiz/:quizId}
    \item Backend \texttt{authMiddleware} verifies token, extracts user ID
    \item Progress route handler updates \texttt{User} model in MongoDB
    \item Updated progress returned to frontend
    \item Local state updated, UI reflects changes
\end{enumerate}

\subsubsection{AI Assistance Flow}
\begin{enumerate}
    \item User requests hint or analysis in \texttt{FASimulation}
    \item Component calls \texttt{GeminiService.getHint()} or \texttt{analyzeErrors()}
    \item \texttt{GeminiService} constructs prompt with current FA state and problem context
    \item Request sent to Google Gemini API via HTTPS
    \item AI generates educational response
    \item Response parsed and displayed in \texttt{AIHelper} component
\end{enumerate}

\subsubsection{Data Passing Between Components}

\begin{itemize}
    \item \textbf{Props:} React props pass data from parent to child components (e.g., \texttt{quiz} prop to \texttt{QuizPage}, \texttt{problem} prop to \texttt{FASimulation})
    
    \item \textbf{Context:} \texttt{AuthContext} provides user data and authentication methods to all components via \texttt{useAuth()} hook
    
    \item \textbf{API Responses:} JSON objects containing user data, progress statistics, problem definitions, and AI-generated content
    
    \item \textbf{Local Storage:} Authentication tokens and user data cached in browser localStorage for session persistence
    
    \item \textbf{State Management:} Component-level state (useState) for UI state, Context for global authentication state
\end{itemize}

\section{Persistence}

\subsection{Data Persistence Strategy}

The application uses a hybrid persistence approach: MongoDB for long-term storage and browser localStorage for session management. JSON is used as the primary data format for API communication and serialization (instead of XML) to simplify syntax and leverage native JavaScript support.

\subsection{Persisted Data}

\subsubsection{User Account \& Progress Data}
\textbf{Storage Location:} MongoDB database (\texttt{acceptly} database, \texttt{users} collection)

\textbf{Data Structure:} MongoDB document containing:
\begin{itemize}
    \item \textbf{Account:} \texttt{username}, \texttt{email}, \texttt{password} (bcrypt hashed), \texttt{createdAt}, \texttt{lastLogin}
    \item \textbf{Progress:} Nested \texttt{progress} object with \texttt{faSimulation} and \texttt{mcqs} sub-objects, each containing problem/quiz arrays with \texttt{problemId/quizId}, \texttt{status}, \texttt{attempts}, \texttt{lastAttempt}, and \texttt{bestScore}
\end{itemize}

\subsubsection{Session Data}
\textbf{Storage Location:} Browser localStorage (client-side)

\textbf{Data:} \texttt{acceptly\_token} (JWT), \texttt{acceptly\_user} (serialized JSON). Maintains user session across page refreshes.

\subsection{Storage Format}

\subsubsection{JSON vs XML Choice}
JSON is used instead of XML because: (1) Simplified syntax reducing parsing complexity, (2) Native JavaScript support with built-in \texttt{JSON.parse()}/\texttt{JSON.stringify()}, (3) Better fit for JavaScript-based web applications, (4) Reduced data overhead, (5) Industry standard for RESTful APIs.

\subsubsection{MongoDB}
BSON (Binary JSON) documents stored in a document-oriented NoSQL database on separate hardware (layered architecture). Schema defined via Mongoose ODM (\texttt{User.js}). Connection via \texttt{MONGODB\_URI} environment variable. Free, open-source, scalable for this application scale.

\subsubsection{localStorage}
Key-value pairs stored as strings in browser's persistent storage. Objects serialized via \texttt{JSON.stringify()}.

\subsection{Data Access \& Synchronization}

\textbf{Read Operations:} User progress via \texttt{GET /api/progress}, user data via \texttt{GET /api/auth/me}, problems/quizzes from static files.

\textbf{Write Operations:} Progress updates after completion, user registration creates new documents, login updates \texttt{lastLogin} timestamp.

\textbf{Synchronization:} Optimistic updates (frontend updates immediately, then syncs), JWT token validation on each request, last-write-wins conflict resolution for progress updates.

\section{Languages Used}

\begin{itemize}
    \item \textbf{JavaScript (ES6+):} Core language for frontend and backend.
    \item \textbf{JSX:} React templating syntax.
    \item \textbf{CSS:} Styling and responsive layout.
    \item \textbf{JSON:} API communication format.
    \item \textbf{HTML \& Markdown:} Base markup and documentation.
\end{itemize}

\section{Deployment}

\subsection{Deployment Architecture}
\begin{itemize}
    \item \textbf{Frontend:} React app hosted on Netlify/Vercel/AWS S3.
    \item \textbf{Backend:} Express server deployed on Heroku, AWS, or Render.
    \item \textbf{Database:} MongoDB Atlas (cloud-hosted).
    \item \textbf{AI Service:} Google Gemini accessed via HTTPS.
\end{itemize}

\subsection{Deployment Process}
\begin{enumerate}
    \item Build production bundle using \texttt{npm run build}.
    \item Deploy \texttt{build/} directory to hosting platform.
    \item Configure environment variables (API KEYS, API URLS, etc.).
\end{enumerate}

\section{Conclusion}

This architectural design document provides a comprehensive overview of the Acceptly application's software architecture. The system follows modern web development best practices with a clear separation of concerns between frontend, backend, and external services. The use of React Context API for state management, service layer pattern for API abstraction, and RESTful API design ensures maintainability and scalability.

The application's hybrid persistence strategy (MongoDB + localStorage) balances long-term data storage with user experience, while the integration of Google Gemini AI provides intelligent educational assistance. The deployment strategy supports both development and production environments, with flexibility for cloud hosting platforms.

This architecture supports the application's core educational goals while providing a solid foundation for future enhancements and scalability.

\end{document}

